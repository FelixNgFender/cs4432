# CS 4432 Project 2: Indexing

Author: Thinh Nguyen - 670714455

## Get started

`make test` to run the default test.

`make report` to run the default test and generate a report in the `./out`
directory. You can add a `--keep` flag to keep intermediate files generated by
the report generator. For the report generator to work, you cannot add or remove
any queries. You can change the numbers in `./Project2Dataset/in.txt` but the
last 3 queries must be the same as the first 3 queries because the report
generator will compare the query results before and after indexing pair-wise.

`make run` will compile the `main` executable in the `./bin` directory.

`make` alone compiles the executable and copies over the test data to the build
directory.

`make clean` to clean up compiled files, test copies and reports.

## Test results

Report generated from running the default test.

```shell
===== QUERY PERFORMANCE REPORT =====
--- Query 1 (Before Index) ---
Index type used: Table Scan
Number of data files read: 99
Time taken to answer the query: 6 ms
--- Query 5 (After Index) ---
Index type used: Hash-based index
Number of data files read: 2
Time taken to answer the query: 0 ms
--- Query 2 (Before Index) ---
Index type used: Table Scan
Number of data files read: 99
Time taken to answer the query: 6 ms
--- Query 6 (After Index) ---
Index type used: Array-based index
Number of data files read: 70
Time taken to answer the query: 0 ms
--- Query 3 (Before Index) ---
Index type used: Table Scan
Number of data files read: 99
Time taken to answer the query: 7 ms
--- Query 7 (After Index) ---
Index type used: Table Scan
Number of data files read: 99
Time taken to answer the query: 7 ms

===== QUERY OUTPUT COMPARISON =====

✅ Query 1 and 5 outputs match (ignoring order)
✅ Query 2 and 6 outputs match (ignoring order)
✅ Query 3 and 7 outputs match (ignoring order)
```

Notice how faster we can answer equality and range queries (1 vs 5, 2 vs 6) and
less sorting through data files after indexing. For inequality query (3 vs 7),
nothing should change.

## Design decisions

Nothing outside of the guidelines.

An interesting optimization I did is sorting the record locations obtained from
the indexes by block ID and record ID before passing them to the record manager
to get the actual records. This majorly reduces page swaps and sets the upper
bound of page swaps to be the same as that of the table scan algorithm. You can
test this out setting a wider range for the range query. Notice how it caps out
at 99 and always swap fewer pages than table scan.
